"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMedianValue = void 0;
var logger = require("../utils/logger")("aggregators/median-aggregator");
var medianAggregator = {
    getAggregatedValue: function (price, maxPriceDeviationPercent) {
        var symbol = price.symbol;
        var validValues = Object.values(price.source).filter(function (v) { return !isNaN(v) && v > 0; });
        if (validValues.length === 0) {
            throw new Error("No valid values for symbol: " + price.symbol);
        }
        var initialMedian = getMedianValue(validValues);
        // Filtering out values based on deviation from the initial median
        var stableValues = [];
        for (var _i = 0, _a = Object.keys(price.source); _i < _a.length; _i++) {
            var sourceName = _a[_i];
            var value = price.source[sourceName];
            var deviation = (Math.abs(value - initialMedian) / initialMedian) * 100;
            if (isNaN(value)) {
                // We don't log warnings for "error" values
                // because these values represent fetching fails
                // which should already be logged as warning
                if (value !== "error") {
                    logger.warn("Incorrect price value (NaN) for source: " + sourceName + ". "
                        + ("Symbol: " + symbol + ". Value: " + value), price);
                }
            }
            else if (value <= 0) {
                logger.warn("Incorrect price value (<= 0) for source: " + sourceName + ". "
                    + ("Symbol: " + symbol + ". Value: " + value), price);
            }
            else if (deviation > maxPriceDeviationPercent) {
                logger.info("Value " + value + " has too big deviation for symbol: " + symbol + " "
                    + ("and source: " + sourceName + ". Deviation: (" + deviation + ")%. ")
                    + "Skipping...", price);
            }
            else {
                stableValues.push(value);
            }
        }
        if (stableValues.length === 0) {
            throw new Error("All values have too big deviation for symbol: " + price.symbol);
        }
        return __assign(__assign({}, price), { value: getMedianValue(stableValues) });
    },
};
function getMedianValue(arr) {
    if (arr.length === 0) {
        throw new Error("Cannot get median value of an empty array");
    }
    arr = arr.sort(function (a, b) { return a - b; });
    var middle = Math.floor(arr.length / 2);
    if (arr.length % 2 === 0) {
        return (arr[middle] + arr[middle - 1]) / 2;
    }
    else {
        return arr[middle];
    }
}
exports.getMedianValue = getMedianValue;
exports.default = medianAggregator;
